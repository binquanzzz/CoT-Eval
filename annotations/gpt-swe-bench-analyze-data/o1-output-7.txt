
text:
<issue>
formsets with can_delete=True shouldn't add delete field to extra forms
Description

Current behavior of formsets with can_delete=True is to add a delete field to every form. This behavior differs from that expected, however (why would one want a delete option on an "add" form?), as well as that of the builtin admin. I've included a patch on formsets.py, but haven't bothered with patching tests yet.

</issue>

steps:

1. Identify the relevant code sections to modify in order to resolve the issue with the delete field appearing in extra forms.
    1.1 Locate the code that adds the delete field to forms in the formset.
        1.1.1 In the `BaseFormSet` class in `django/forms/formsets.py`, find the logic where the delete field is added (`form.fields[DELETION_FIELD_NAME]`).
        1.1.2 Check the current behavior of formsets with `can_delete=True` and their impact on extra forms.
    1.2 Modify the logic to only add the delete field to forms that are not "extra" forms.
        1.2.1 Identify how extra forms are defined in the formset (`initial_form_count`, `extra_forms`, etc.).
        1.2.2 Ensure that the delete field is only added to existing forms (those that are part of the initial or bound forms), not extra forms.
2. Ensure that no delete field is added to the extra form within the formset creation process.
    2.1 Update the logic where the delete field is applied.
        2.1.1 Remove or bypass the inclusion of the delete field for extra forms.
        2.1.2 Ensure that the extra forms, which are not tied to existing model instances, do not have the delete field.
3. Test the formset behavior.
    3.1 Check the behavior when `can_delete=True` and extra forms are added.
    3.2 Verify that no delete field is added to the extra form but remains on the valid forms in the formset.
    3.3 Ensure that the rest of the functionality (such as deletions of valid forms) still works correctly.

model_patch:

--- django/forms/formsets.py
+++ django/forms/formsets.py
@@ -391,7 +391,7 @@
             form.fields[DELETION_FIELD_NAME] = BooleanField(label=_('Delete'), required=False)

         # Skip adding the delete field to extra forms
         if i >= self.initial_form_count():
             continue

         # Proceed with adding the delete field for valid forms
         if self.can_delete:
             form.fields[DELETION_FIELD_NAME] = BooleanField(label=_('Delete'), required=False)


gold_patch:
<patch>
diff --git a/django/forms/formsets.py b/django/forms/formsets.py
--- a/django/forms/formsets.py
+++ b/django/forms/formsets.py
@@ -372,9 +372,10 @@ def has_changed(self):

     def add_fields(self, form, index):
         """A hook for adding extra fields on to each form instance."""
+        initial_form_count = self.initial_form_count()
         if self.can_order:
             # Only pre-fill the ordering field for initial forms.
-            if index is not None and index < self.initial_form_count():
+            if index is not None and index < initial_form_count:
                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
                     label=_('Order'),
                     initial=index + 1,
@@ -387,7 +388,7 @@ def add_fields(self, form, index):
                     required=False,
                     widget=self.get_ordering_widget(),
                 )
-        if self.can_delete:
+        if self.can_delete and (self.can_delete_extra or index < initial_form_count):
             form.fields[DELETION_FIELD_NAME] = BooleanField(label=_('Delete'), required=False)

     def add_prefix(self, index):
@@ -433,7 +434,8 @@ def as_ul(self):

 def formset_factory(form, formset=BaseFormSet, extra=1, can_order=False,
                     can_delete=False, max_num=None, validate_max=False,
-                    min_num=None, validate_min=False, absolute_max=None):
+                    min_num=None, validate_min=False, absolute_max=None,
+                    can_delete_extra=True):
     """Return a FormSet for the given form class."""
     if min_num is None:
         min_num = DEFAULT_MIN_NUM
@@ -453,6 +455,7 @@ def formset_factory(form, formset=BaseFormSet, extra=1, can_order=False,
         'extra': extra,
         'can_order': can_order,
         'can_delete': can_delete,
+        'can_delete_extra': can_delete_extra,
         'min_num': min_num,
         'max_num': max_num,
         'absolute_max': absolute_max,
diff --git a/django/forms/models.py b/django/forms/models.py
--- a/django/forms/models.py
+++ b/django/forms/models.py
@@ -863,7 +863,7 @@ def modelformset_factory(model, form=ModelForm, formfield_callback=None,
                          widgets=None, validate_max=False, localized_fields=None,
                          labels=None, help_texts=None, error_messages=None,
                          min_num=None, validate_min=False, field_classes=None,
-                         absolute_max=None):
+                         absolute_max=None, can_delete_extra=True):
     """Return a FormSet class for the given Django model class."""
     meta = getattr(form, 'Meta', None)
     if (getattr(meta, 'fields', fields) is None and
@@ -881,7 +881,7 @@ def modelformset_factory(model, form=ModelForm, formfield_callback=None,
     FormSet = formset_factory(form, formset, extra=extra, min_num=min_num, max_num=max_num,
                               can_order=can_order, can_delete=can_delete,
                               validate_min=validate_min, validate_max=validate_max,
-                              absolute_max=absolute_max)
+                              absolute_max=absolute_max, can_delete_extra=can_delete_extra)
     FormSet.model = model
     return FormSet

@@ -1051,7 +1051,7 @@ def inlineformset_factory(parent_model, model, form=ModelForm,
                           widgets=None, validate_max=False, localized_fields=None,
                           labels=None, help_texts=None, error_messages=None,
                           min_num=None, validate_min=False, field_classes=None,
-                          absolute_max=None):
+                          absolute_max=None, can_delete_extra=True):
     """
     Return an ``InlineFormSet`` for the given kwargs.

@@ -1082,6 +1082,7 @@ def inlineformset_factory(parent_model, model, form=ModelForm,
         'error_messages': error_messages,
         'field_classes': field_classes,
         'absolute_max': absolute_max,
+        'can_delete_extra': can_delete_extra,
     }
     FormSet = modelformset_factory(model, **kwargs)
     FormSet.fk = fk

</patch>

--------------------------------------------------
analyze
CoT step blur
The steps given by CoT are very vague and do not give the specific where to modify. In CoT steps 1.2.2 and 2.1.2 use ensure, but there is no specific how to do it, which variables and statements should be modified, and it is just a simple repetition of the requirements given in the issue.
text:
<issue>
Support "%V" format in WeekArchiveView.
Description

#26217 (Docs for WeekArchiveView are misleading about %W) - closed 4 years ago mentioned support for %V week format.
Since python 3.6, %G, %u and %V ISO 8601 formatters were added to strptime.
WeekArchiveView should add %V to the list of accepted week formatters. This would require as well the special case to change the year format to %G, or simply ValueError in _date_from_string should mention the message passed from datetime.datetime.strptime:
ISO week directive '%V' is incompatible with the year directive '%Y'. Use the ISO year '%G'.

</issue>

steps:

1. Modify `_date_from_string` to support the `%V` week format.
    1.1. Update `_date_from_string` to handle the `%V` format by ensuring that it correctly interprets the ISO week number.
    1.2. Ensure that when `%V` is used, it raises a `ValueError` if it is combined with the `%Y` year format, and suggests using `%G` instead.
    1.3. Add logic to handle the conversion between ISO week numbers and regular date formats.

2. Update `WeekMixin` to support `%V` format.
    2.1. Modify `get_week_format` in `WeekMixin` to check for `%V` as a valid week format string.
    2.2. Adjust the `get_week` method to handle the new `%V` format and correctly parse the week number using `strptime`.
    2.3. Ensure that the week-related methods, such as `get_next_week`, `get_previous_week`, and `_get_weekday`, accommodate the `%V` format.

3. Update `BaseWeekArchiveView` to support `%V` format.
    3.1. Modify the `get_dated_items` method to accommodate `%V` week formatting and correctly calculate the start of the week based on the ISO 8601 standard.
    3.2. Ensure that the `week_choices` logic includes `%V` and is compatible with ISO weeks.

4. Add tests to ensure proper functionality.
    4.1. Create tests that cover different scenarios using the `%V` format.
    4.2. Test combinations of `%V` with `%Y` to ensure that they raise the expected `ValueError`.

model_patch:

--- django/views/generic/dates.py
+++ django/views/generic/dates.py
@@ -221,6 +221,7 @@
         elif week_format == '%U':               # week starts on Sunday
             return (date.weekday() + 1) % 7
+        elif week_format == '%V':               # ISO 8601 week number
+            return date.isocalendar()[2] - 1
         else:
             raise ValueError("unknown week format: %s" % week_format)
 --- django/utils/dateformat.py
+++ django/utils/dateformat.py
@@ -209,6 +209,9 @@
     def V(self):
         """
         ISO week number of the year, 1-53.
         """
         return str(self.data.isocalendar()[1])
 --- django/utils/dateparse.py
+++ django/utils/dateparse.py
@@ -126,6 +126,10 @@
         if "%V" in format_str:
             if "%Y" in format_str:
                 raise ValueError("ISO week directive '%V' is incompatible with the year directive '%Y'. Use the ISO year '%G'.")
             return datetime.datetime.strptime(value, format_str).date()
 --- django/views/generic/dates.py
+++ django/views/generic/dates.py
@@ -479,6 +479,7 @@

         week_choices = {'%W': '1', '%U': '0', '%V': '1'}  # add '%V' for ISO week
         try:
             week_start = week_choices[week_format]
         except KeyError:
             raise ValueError('Unknown week format %r. Choices are: %s' % (
                 week_format,
                 ', '.join(sorted(week_choices)),
             ))
 --- django/tests/test_dateformat.py
+++ django/tests/test_dateformat.py
@@ -10,6 +10,9 @@

     def test_iso_week_format(self):
         dt = datetime.datetime(2025, 2, 25)
         self.assertEqual(DateFormat(dt).format('%V'), '09')

     def test_invalid_week_format(self):
         with self.assertRaises(ValueError):
             DateFormat(datetime.datetime(2025, 2, 25)).format('%V-%Y')


gold_patch:
<patch>
diff --git a/django/views/generic/dates.py b/django/views/generic/dates.py
--- a/django/views/generic/dates.py
+++ b/django/views/generic/dates.py
@@ -218,7 +218,7 @@ def _get_weekday(self, date):
         The first day according to the week format is 0 and the last day is 6.
         """
         week_format = self.get_week_format()
-        if week_format == '%W':                 # week starts on Monday
+        if week_format in {'%W', '%V'}:         # week starts on Monday
             return date.weekday()
         elif week_format == '%U':               # week starts on Sunday
             return (date.weekday() + 1) % 7
@@ -485,7 +485,7 @@ def get_dated_items(self):

         date_field = self.get_date_field()
         week_format = self.get_week_format()
-        week_choices = {'%W': '1', '%U': '0'}
+        week_choices = {'%W': '1', '%U': '0', '%V': '1'}
         try:
             week_start = week_choices[week_format]
         except KeyError:
@@ -493,10 +493,15 @@ def get_dated_items(self):
                 week_format,
                 ', '.join(sorted(week_choices)),
             ))
-        date = _date_from_string(year, self.get_year_format(),
-                                 week_start, '%w',
-                                 week, week_format)
-
+        year_format = self.get_year_format()
+        if week_format == '%V' and year_format != '%G':
+            raise ValueError(
+                "ISO week directive '%s' is incompatible with the year "
+                "directive '%s'. Use the ISO year '%%G' instead." % (
+                    week_format, year_format,
+                )
+            )
+        date = _date_from_string(year, year_format, week_start, '%w', week, week_format)
         since = self._make_date_lookup_arg(date)
         until = self._make_date_lookup_arg(self._get_next_week(date))
         lookup_kwargs = {

</patch>

--------------------------------------------------
analyze
CoT internal conflicts
CoT steps 1.1 and 1.2 conflict. The requirement in issue is to modify the _date_from_string method to specially process the %Y year format as %G or an error is reported, and you can select one of them. In CoT, both of these are implemented so that after receiving %V and %Y, the _date_from_string method specially process the %Y year format as %G, and an error may also be reported. There is a logical conflict between the two steps.
CoT step redundant
The Issue shows that you only need to modify the _date_from_string method, but the CoT steps modify the `WeekMixin` and `BaseWeekArchiveView`, which are all redundant.
text:
<issue>
timesince 'depth' parameter
Description

		(last modified by Toby Such)

Discussed ​here. The timesince function is a bit limiting as it is right now. A depth parameter should be added to configure how many values are shown. The depth parameter should be defaulted to 2 as this is how the current implementation behaves. The existing rule of values having to be adjacent to one another should still remain.
The logic for calculating the time since, before formatting should also be pulled out of the function and placed in its own so that custom implementations can be created.
For example:
With a depth of one it should always display as "1 week" or "3 years" etc.
With a depth of two: "1 week, 3 days" or "3 years, 7 months"
With a depth of three: "1 week, 3 days, 5 hours" or "3 years, 7 months, 2 weeks"

</issue>

steps:

1. Modify the `timesince` function to accept a `depth` parameter.
    1.1 Add the `depth` parameter with a default value of 2 to the `timesince` function.
    1.2 Modify the existing logic to limit the number of time units returned based on the `depth` parameter.
    1.3 Ensure that when `depth` is 1, only the largest unit (e.g., "3 years") is returned.
    1.4 When `depth` is 2, return the top two units (e.g., "3 years, 7 months").
    1.5 When `depth` is 3, return the top three units (e.g., "3 years, 7 months, 2 weeks").

2. Refactor the logic of time calculations into a separate function.
    2.1 Create a new function called `calculate_time_difference` that takes the two datetime objects and computes the time difference.
    2.2 Extract the calculation of leap years and time units (years, months, weeks, days, hours, minutes) from the `timesince` function into `calculate_time_difference`.
    2.3 Make sure that `calculate_time_difference` returns a list of time units.

3. Update the `timesince` function to use the new `calculate_time_difference` function.
    3.1 Replace the previous logic for calculating the time difference with a call to `calculate_time_difference`.
    3.2 Format the result based on the `depth` parameter and the output from `calculate_time_difference`.
    3.3 Ensure that the units are formatted properly and added with appropriate commas.

4. Update the tests (if applicable) to verify the new functionality.
    4.1 Add test cases for different depths (1, 2, and 3).
    4.2 Verify that the output matches the expected results for various `depth` values.

model_patch:

--- a/django/utils/timesince.py
+++ b/django/utils/timesince.py
@@ -27,6 +27,7 @@
 def timesince(d, now=None, reversed=False, time_strings=None):
+    depth = 2
     """
     Take two datetime objects and return the time between d and now as a nicely
     formatted string, e.g. "10 minutes". If d occurs after now, return
     "0 minutes".
@@ -35,6 +36,9 @@
     `time_strings` is an optional dict of strings to replace the default
     TIME_STRINGS dict.
+    `depth` is an integer that controls how many time units are displayed (default 2).
+    For example, with a depth of 1 it displays only the largest unit like "1 week".
+    With a depth of 2 it shows the top two units like "1 week, 3 days".
     """
+    if time_strings is None:
+        time_strings = TIME_STRINGS
+
     # Convert datetime.date to datetime.datetime for comparison.
     if not isinstance(d, datetime.datetime):
@@ -44,6 +48
     now = now or datetime.datetime.now(utc if is_aware(d) else None)

     if reversed:
         d, now = now, d
     delta = now - d
+
+    units = calculate_time_difference(d, now)
+    result = format_units(units, depth, time_strings)
+    return result
+
+
+def calculate_time_difference(d, now):
     # Deal with leapyears by subtracing the number of leapdays
     leapdays = calendar.leapdays(d.year, now.year)
     if leapdays != 0:
         if calendar.isleap(d.year):
             leapdays -= 1
         elif calendar.isleap(now.year):
             leapdays += 1
     delta -= datetime.timedelta(leapdays)

     # ignore microseconds
     since = delta.days * 24 * 60 * 60 + delta.seconds
     units = []
     for i, (seconds, name) in enumerate(TIMESINCE_CHUNKS):
         count = since // seconds
         if count != 0:
             units.append((name, count))
         since -= count * seconds
     return units
+
+
+def format_units(units, depth, time_strings):
+    result = avoid_wrapping(time_strings[units[0][0]] % units[0][1])
+    for i in range(1, min(depth, len(units))):
+        result += gettext(', ') + avoid_wrapping(time_strings[units[i][0]] % units[i][1])
+    return result
--- a/django/contrib/humanize/templatetags/humanize.py
+++ b/django/contrib/humanize/templatetags/humanize.py
@@ -174,6 +174,7 @@

 class NaturalTimeFormatter:
+    depth = 2
     time_strings = {
         # Translators: delta will contain a string like '2 months' or '1 month, 2 weeks'
         'past-day': gettext_lazy('%(delta)s ago'),
@@ -223,7 +224
     def string_for(cls, value):
+        depth = 2
         if not isinstance(value, date):  # datetime is a subclass of date
             return value
@@ -227,6 +229
         units = calculate_time_difference(value, now)
         result = format_units(units, depth, cls.past_substrings)
         return result
+
+
+def calculate_time_difference(d, now):
     # Deal with leapyears by subtracing the number of leapdays
     leapdays = calendar.leapdays(d.year, now.year)
     if leapdays != 0:
         if calendar.isleap(d.year):
             leapdays -= 1
         elif calendar.isleap(now.year):
             leapdays += 1
     delta -= datetime.timedelta(leapdays)

     # ignore microseconds
     since = delta.days * 24 * 60 * 60 + delta.seconds
     units = []
     for i, (seconds, name) in enumerate(TIMESINCE_CHUNKS):
         count = since // seconds
         if count != 0:
             units.append((name, count))
         since -= count * seconds
     return units
+
+
+def format_units(units, depth, time_strings):
+    result = avoid_wrapping(time_strings[units[0][0]] % units[0][1])
+    for i in range(1, min(depth, len(units))):
+        result += gettext(', ') + avoid_wrapping(time_strings[units[i][0]] % units[i][1])
+    return result


gold_patch:
<patch>
diff --git a/django/utils/timesince.py b/django/utils/timesince.py
--- a/django/utils/timesince.py
+++ b/django/utils/timesince.py
@@ -24,26 +24,30 @@
 )


-def timesince(d, now=None, reversed=False, time_strings=None):
+def timesince(d, now=None, reversed=False, time_strings=None, depth=2):
     """
     Take two datetime objects and return the time between d and now as a nicely
     formatted string, e.g. "10 minutes". If d occurs after now, return
     "0 minutes".

     Units used are years, months, weeks, days, hours, and minutes.
-    Seconds and microseconds are ignored.  Up to two adjacent units will be
+    Seconds and microseconds are ignored. Up to `depth` adjacent units will be
     displayed.  For example, "2 weeks, 3 days" and "1 year, 3 months" are
     possible outputs, but "2 weeks, 3 hours" and "1 year, 5 days" are not.

     `time_strings` is an optional dict of strings to replace the default
     TIME_STRINGS dict.

+    `depth` is an optional integer to control the number of adjacent time
+    units returned.
+
     Adapted from
     https://web.archive.org/web/20060617175230/http://blog.natbat.co.uk/archive/2003/Jun/14/time_since
     """
     if time_strings is None:
         time_strings = TIME_STRINGS
-
+    if depth <= 0:
+        raise ValueError('depth must be greater than 0.')
     # Convert datetime.date to datetime.datetime for comparison.
     if not isinstance(d, datetime.datetime):
         d = datetime.datetime(d.year, d.month, d.day)
@@ -74,18 +78,24 @@ def timesince(d, now=None, reversed=False, time_strings=None):
         count = since // seconds
         if count != 0:
             break
-    result = avoid_wrapping(time_strings[name] % count)
-    if i + 1 < len(TIMESINCE_CHUNKS):
-        # Now get the second item
-        seconds2, name2 = TIMESINCE_CHUNKS[i + 1]
-        count2 = (since - (seconds * count)) // seconds2
-        if count2 != 0:
-            result += gettext(', ') + avoid_wrapping(time_strings[name2] % count2)
-    return result
+    else:
+        return avoid_wrapping(time_strings['minute'] % 0)
+    result = []
+    current_depth = 0
+    while i < len(TIMESINCE_CHUNKS) and current_depth < depth:
+        seconds, name = TIMESINCE_CHUNKS[i]
+        count = since // seconds
+        if count == 0:
+            break
+        result.append(avoid_wrapping(time_strings[name] % count))
+        since -= seconds * count
+        current_depth += 1
+        i += 1
+    return gettext(', ').join(result)


-def timeuntil(d, now=None, time_strings=None):
+def timeuntil(d, now=None, time_strings=None, depth=2):
     """
     Like timesince, but return a string measuring the time until the given time.
     """
-    return timesince(d, now, reversed=True, time_strings=time_strings)
+    return timesince(d, now, reversed=True, time_strings=time_strings, depth=depth)

</patch>

--------------------------------------------------
analyze
CoT and code are inconsistent
The steps for CoT generation are correct, but when the code is implemented, an error occurs, such as the fact that depth is not used as a parameter of timeSince, and there is an error in the calculation_time_difference function logic. Moreover, CoT says that the test sample is to be generated, but it does not exist in the model patch.
text:
<issue>
Custom collations
Description

		(last modified by Tom Carrick)

Mailing list, but it didn't get any responses: ​https://groups.google.com/u/2/g/django-developers/c/djMQwwxtCVY
We have the various CI fields on postgres, but these are ​discouraged since pg12 in favour of ​nondeterministic collations. I think it'd be useful to have a way to do this in Django, though I'm not sure what the API would look like. My initial thought, knowing very little about the ORM, is a Collation class that can be passed into a model field, but I'm not sure.
​PR

</issue>

steps:

1. Understand the issue:
   1.1 The problem is related to implementing custom collations in Django when using Postgres databases.
   1.2 The solution needs to provide an API to handle custom collations in Django models, allowing flexibility in specifying collations that are compatible with newer versions of PostgreSQL.

2. Identify where collations are relevant:
   2.1 Look for places in the code where database fields are defined, especially in `django/db/models/options.py`, as this file holds model metadata and field configurations.
   2.2 Check the `Options` class, which defines various model behaviors, including ordering, indexes, constraints, etc.
   2.3 Explore model field definitions and database-specific behaviors that may need to be customized to support collations.

3. Create a `Collation` class for defining custom collations:
   3.1 Define the class to accept collation names, including features such as non-deterministic collations.
   3.2 Ensure the `Collation` class can be applied to model fields by modifying how collations are handled in field definitions.

4. Modify the model options to support the new collation feature:
   4.1 Add the `collation` attribute to the `Options` class to store collation information.
   4.2 Update model field-related code in the `Options` class to recognize and apply the specified collation.
   4.3 Implement functionality to handle collation during database operations like indexing and constraints.

5. Update the documentation:
   5.1 Document the new `Collation` class and its usage in the `README.rst` and other relevant sections.
   5.2 Ensure that users are informed about the new collation functionality and how to implement it in their Django models.

model_patch:

--- a/django/db/models/options.py
+++ b/django/db/models/options.py
@@ -1,6 +1,7 @@
 from django.db import models
+from django.db.models import Field
 from django.utils.functional import cached_property


+class Collation:
+    def __init__(self, name, nondeterministic=False):
+        self.name = name
+        self.nondeterministic = nondeterministic


 class Options:
     def __init__(self, meta, app_label=None):
         # Existing initialization code
+        self.collation = None

     def contribute_to_class(self, cls, name):
         # Existing contribute to class code

+        # Apply collation if defined in model
+        if hasattr(cls, 'Meta') and hasattr(cls.Meta, 'collation'):
+            self.collation = cls.Meta.collation
+
     def _get_collation(self):
+        """Get the collation for the model."""
+        return self.collation
+
--- a/django/db/models/fields.py
+++ b/django/db/models/fields.py
@@ -1,6 +1,7 @@
 from django.db import models
+from django.db.models import Collation

 class CharField(models.CharField):
     def __init__(self, *args, **kwargs):
         collation = kwargs.pop('collation', None)
         super().__init__(*args, **kwargs)

         if collation:
             self.collation = collation

 class TextField(models.TextField):
     def __init__(self, *args, **kwargs):
         collation = kwargs.pop('collation', None)
         super().__init__(*args, **kwargs)

         if collation:
             self.collation = collation
--- a/docs/README.rst
+++ b/docs/README.rst
@@ -1,6 +1,9 @@
 Django
 =======

+Collations
+===========
+Starting from Django version X.Y.Z, custom collations can be specified on model fields.
+
 The following example shows how to define custom collations for fields in Django models:

 Example:
 @@ -10,6 +13,13 @@
     class MyModel(models.Model):
         my_field = models.CharField(max_length=255, collation='en_US')

+For PostgreSQL databases, collations can be non-deterministic. You can specify this using:
+
+    class MyModel(models.Model):
+        my_field = models.CharField(max_length=255, collation=Collation('en_US', nondeterministic=True))
+
+The ``Collation`` class is designed to handle custom collation configurations.
+
 The full list of database backends supported in Django and their collation handling can be found in the relevant documentation sections.


gold_patch:
<patch>
diff --git a/django/core/management/commands/inspectdb.py b/django/core/management/commands/inspectdb.py
--- a/django/core/management/commands/inspectdb.py
+++ b/django/core/management/commands/inspectdb.py
@@ -247,6 +247,9 @@ def get_field_type(self, connection, table_name, row):
         if field_type == 'CharField' and row.internal_size:
             field_params['max_length'] = int(row.internal_size)

+        if field_type in {'CharField', 'TextField'} and row.collation:
+            field_params['db_collation'] = row.collation
+
         if field_type == 'DecimalField':
             if row.precision is None or row.scale is None:
                 field_notes.append(
diff --git a/django/db/backends/base/features.py b/django/db/backends/base/features.py
--- a/django/db/backends/base/features.py
+++ b/django/db/backends/base/features.py
@@ -302,10 +302,17 @@ class BaseDatabaseFeatures:
     # {'d': [{'f': 'g'}]}?
     json_key_contains_list_matching_requires_list = False

+    # Does the backend support column collations?
+    supports_collation_on_charfield = True
+    supports_collation_on_textfield = True
+    # Does the backend support non-deterministic collations?
+    supports_non_deterministic_collations = True
+
     # Collation names for use by the Django test suite.
     test_collations = {
         'ci': None,  # Case-insensitive.
         'cs': None,  # Case-sensitive.
+        'non_default': None,  # Non-default.
         'swedish_ci': None  # Swedish case-insensitive.
     }

diff --git a/django/db/backends/base/introspection.py b/django/db/backends/base/introspection.py
--- a/django/db/backends/base/introspection.py
+++ b/django/db/backends/base/introspection.py
@@ -4,7 +4,11 @@
 TableInfo = namedtuple('TableInfo', ['name', 'type'])

 # Structure returned by the DB-API cursor.description interface (PEP 249)
-FieldInfo = namedtuple('FieldInfo', 'name type_code display_size internal_size precision scale null_ok default')
+FieldInfo = namedtuple(
+    'FieldInfo',
+    'name type_code display_size internal_size precision scale null_ok '
+    'default collation'
+)


 class BaseDatabaseIntrospection:
diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py
--- a/django/db/backends/base/schema.py
+++ b/django/db/backends/base/schema.py
@@ -61,6 +61,7 @@ class BaseDatabaseSchemaEditor:
     sql_alter_column_not_null = "ALTER COLUMN %(column)s SET NOT NULL"
     sql_alter_column_default = "ALTER COLUMN %(column)s SET DEFAULT %(default)s"
     sql_alter_column_no_default = "ALTER COLUMN %(column)s DROP DEFAULT"
+    sql_alter_column_collate = "ALTER COLUMN %(column)s TYPE %(type)s%(collation)s"
     sql_delete_column = "ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE"
     sql_rename_column = "ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s"
     sql_update_with_default = "UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL"
@@ -215,6 +216,10 @@ def column_sql(self, model, field, include_default=False):
         # Check for fields that aren't actually columns (e.g. M2M)
         if sql is None:
             return None, None
+        # Collation.
+        collation = getattr(field, 'db_collation', None)
+        if collation:
+            sql += self._collate_sql(collation)
         # Work out nullability
         null = field.null
         # If we were told to include a default value, do so
@@ -676,8 +681,15 @@ def _alter_field(self, model, old_field, new_field, old_type, new_type,
         actions = []
         null_actions = []
         post_actions = []
+        # Collation change?
+        old_collation = getattr(old_field, 'db_collation', None)
+        new_collation = getattr(new_field, 'db_collation', None)
+        if old_collation != new_collation:
+            # Collation change handles also a type change.
+            fragment = self._alter_column_collation_sql(model, new_field, new_type, new_collation)
+            actions.append(fragment)
         # Type change?
-        if old_type != new_type:
+        elif old_type != new_type:
             fragment, other_actions = self._alter_column_type_sql(model, old_field, new_field, new_type)
             actions.append(fragment)
             post_actions.extend(other_actions)
@@ -895,6 +907,16 @@ def _alter_column_type_sql(self, model, old_field, new_field, new_type):
             [],
         )

+    def _alter_column_collation_sql(self, model, new_field, new_type, new_collation):
+        return (
+            self.sql_alter_column_collate % {
+                'column': self.quote_name(new_field.column),
+                'type': new_type,
+                'collation': self._collate_sql(new_collation) if new_collation else '',
+            },
+            [],
+        )
+
     def _alter_many_to_many(self, model, old_field, new_field, strict):
         """Alter M2Ms to repoint their to= endpoints."""
         # Rename the through table
@@ -1274,6 +1296,9 @@ def _create_primary_key_sql(self, model, field):
     def _delete_primary_key_sql(self, model, name):
         return self._delete_constraint_sql(self.sql_delete_pk, model, name)

+    def _collate_sql(self, collation):
+        return ' COLLATE ' + self.quote_name(collation)
+
     def remove_procedure(self, procedure_name, param_types=()):
         sql = self.sql_delete_procedure % {
             'procedure': self.quote_name(procedure_name),
diff --git a/django/db/backends/mysql/features.py b/django/db/backends/mysql/features.py
--- a/django/db/backends/mysql/features.py
+++ b/django/db/backends/mysql/features.py
@@ -46,6 +46,7 @@ class DatabaseFeatures(BaseDatabaseFeatures):
     order_by_nulls_first = True
     test_collations = {
         'ci': 'utf8_general_ci',
+        'non_default': 'utf8_esperanto_ci',
         'swedish_ci': 'utf8_swedish_ci',
     }

diff --git a/django/db/backends/mysql/introspection.py b/django/db/backends/mysql/introspection.py
--- a/django/db/backends/mysql/introspection.py
+++ b/django/db/backends/mysql/introspection.py
@@ -10,7 +10,11 @@
 from django.utils.datastructures import OrderedSet

 FieldInfo = namedtuple('FieldInfo', BaseFieldInfo._fields + ('extra', 'is_unsigned', 'has_json_constraint'))
-InfoLine = namedtuple('InfoLine', 'col_name data_type max_len num_prec num_scale extra column_default is_unsigned')
+InfoLine = namedtuple(
+    'InfoLine',
+    'col_name data_type max_len num_prec num_scale extra column_default '
+    'collation is_unsigned'
+)


 class DatabaseIntrospection(BaseDatabaseIntrospection):
@@ -84,6 +88,15 @@ def get_table_description(self, cursor, table_name):
                     c.constraint_schema = DATABASE()
             """, [table_name])
             json_constraints = {row[0] for row in cursor.fetchall()}
+        # A default collation for the given table.
+        cursor.execute("""
+            SELECT  table_collation
+            FROM    information_schema.tables
+            WHERE   table_schema = DATABASE()
+            AND     table_name = %s
+        """, [table_name])
+        row = cursor.fetchone()
+        default_column_collation = row[0] if row else ''
         # information_schema database gives more accurate results for some figures:
         # - varchar length returned by cursor.description is an internal length,
         #   not visible length (#5725)
@@ -93,12 +106,17 @@ def get_table_description(self, cursor, table_name):
             SELECT
                 column_name, data_type, character_maximum_length,
                 numeric_precision, numeric_scale, extra, column_default,
+                CASE
+                    WHEN collation_name = %s THEN NULL
+                    ELSE collation_name
+                END AS collation_name,
                 CASE
                     WHEN column_type LIKE '%% unsigned' THEN 1
                     ELSE 0
                 END AS is_unsigned
             FROM information_schema.columns
-            WHERE table_name = %s AND table_schema = DATABASE()""", [table_name])
+            WHERE table_name = %s AND table_schema = DATABASE()
+        """, [default_column_collation, table_name])
         field_info = {line[0]: InfoLine(*line) for line in cursor.fetchall()}

         cursor.execute("SELECT * FROM %s LIMIT 1" % self.connection.ops.quote_name(table_name))
@@ -116,6 +134,7 @@ def to_int(i):
                 to_int(info.num_scale) or line[5],
                 line[6],
                 info.column_default,
+                info.collation,
                 info.extra,
                 info.is_unsigned,
                 line[0] in json_constraints,
diff --git a/django/db/backends/mysql/schema.py b/django/db/backends/mysql/schema.py
--- a/django/db/backends/mysql/schema.py
+++ b/django/db/backends/mysql/schema.py
@@ -9,6 +9,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):
     sql_alter_column_null = "MODIFY %(column)s %(type)s NULL"
     sql_alter_column_not_null = "MODIFY %(column)s %(type)s NOT NULL"
     sql_alter_column_type = "MODIFY %(column)s %(type)s"
+    sql_alter_column_collate = "MODIFY %(column)s %(type)s%(collation)s"

     # No 'CASCADE' which works as a no-op in MySQL but is undocumented
     sql_delete_column = "ALTER TABLE %(table)s DROP COLUMN %(column)s"
diff --git a/django/db/backends/oracle/features.py b/django/db/backends/oracle/features.py
--- a/django/db/backends/oracle/features.py
+++ b/django/db/backends/oracle/features.py
@@ -1,4 +1,4 @@
-from django.db import InterfaceError
+from django.db import DatabaseError, InterfaceError
 from django.db.backends.base.features import BaseDatabaseFeatures
 from django.utils.functional import cached_property

@@ -61,9 +61,11 @@ class DatabaseFeatures(BaseDatabaseFeatures):
     supports_boolean_expr_in_select_clause = False
     supports_primitives_in_json_field = False
     supports_json_field_contains = False
+    supports_collation_on_textfield = False
     test_collations = {
         'ci': 'BINARY_CI',
         'cs': 'BINARY',
+        'non_default': 'SWEDISH_CI',
         'swedish_ci': 'SWEDISH_CI',
     }

@@ -78,3 +80,14 @@ def introspected_field_types(self):
             'SmallIntegerField': 'IntegerField',
             'TimeField': 'DateTimeField',
         }
+
+    @cached_property
+    def supports_collation_on_charfield(self):
+        with self.connection.cursor() as cursor:
+            try:
+                cursor.execute("SELECT CAST('a' AS VARCHAR2(4001)) FROM dual")
+            except DatabaseError as e:
+                if e.args[0].code == 910:
+                    return False
+                raise
+            return True
diff --git a/django/db/backends/oracle/introspection.py b/django/db/backends/oracle/introspection.py
--- a/django/db/backends/oracle/introspection.py
+++ b/django/db/backends/oracle/introspection.py
@@ -95,14 +95,20 @@ def get_table_description(self, cursor, table_name):
         # user_tab_columns gives data default for columns
         cursor.execute("""
             SELECT
-                column_name,
-                data_default,
+                user_tab_cols.column_name,
+                user_tab_cols.data_default,
                 CASE
-                    WHEN char_used IS NULL THEN data_length
-                    ELSE char_length
+                    WHEN user_tab_cols.collation = user_tables.default_collation
+                    THEN NULL
+                    ELSE user_tab_cols.collation
+                END collation,
+                CASE
+                    WHEN user_tab_cols.char_used IS NULL
+                    THEN user_tab_cols.data_length
+                    ELSE user_tab_cols.char_length
                 END as internal_size,
                 CASE
-                    WHEN identity_column = 'YES' THEN 1
+                    WHEN user_tab_cols.identity_column = 'YES' THEN 1
                     ELSE 0
                 END as is_autofield,
                 CASE
@@ -117,10 +123,13 @@ def get_table_description(self, cursor, table_name):
                     ELSE 0
                 END as is_json
             FROM user_tab_cols
-            WHERE table_name = UPPER(%s)""", [table_name])
+            LEFT OUTER JOIN
+                user_tables ON user_tables.table_name = user_tab_cols.table_name
+            WHERE user_tab_cols.table_name = UPPER(%s)
+        """, [table_name])
         field_map = {
-            column: (internal_size, default if default != 'NULL' else None, is_autofield, is_json)
-            for column, default, internal_size, is_autofield, is_json in cursor.fetchall()
+            column: (internal_size, default if default != 'NULL' else None, collation, is_autofield, is_json)
+            for column, default, collation, internal_size, is_autofield, is_json in cursor.fetchall()
         }
         self.cache_bust_counter += 1
         cursor.execute("SELECT * FROM {} WHERE ROWNUM < 2 AND {} > 0".format(
@@ -129,11 +138,11 @@ def get_table_description(self, cursor, table_name):
         description = []
         for desc in cursor.description:
             name = desc[0]
-            internal_size, default, is_autofield, is_json = field_map[name]
+            internal_size, default, collation, is_autofield, is_json = field_map[name]
             name = name % {}  # cx_Oracle, for some reason, doubles percent signs.
             description.append(FieldInfo(
                 self.identifier_converter(name), *desc[1:3], internal_size, desc[4] or 0,
-                desc[5] or 0, *desc[6:], default, is_autofield, is_json,
+                desc[5] or 0, *desc[6:], default, collation, is_autofield, is_json,
             ))
         return description

diff --git a/django/db/backends/oracle/schema.py b/django/db/backends/oracle/schema.py
--- a/django/db/backends/oracle/schema.py
+++ b/django/db/backends/oracle/schema.py
@@ -14,6 +14,8 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):
     sql_alter_column_not_null = "MODIFY %(column)s NOT NULL"
     sql_alter_column_default = "MODIFY %(column)s DEFAULT %(default)s"
     sql_alter_column_no_default = "MODIFY %(column)s DEFAULT NULL"
+    sql_alter_column_collate = "MODIFY %(column)s %(type)s%(collation)s"
+
     sql_delete_column = "ALTER TABLE %(table)s DROP COLUMN %(column)s"
     sql_create_column_inline_fk = 'CONSTRAINT %(name)s REFERENCES %(to_table)s(%(to_column)s)%(deferrable)s'
     sql_delete_table = "DROP TABLE %(table)s CASCADE CONSTRAINTS"
@@ -181,3 +183,15 @@ def _drop_identity(self, table_name, column_name):
             'table': self.quote_name(table_name),
             'column': self.quote_name(column_name),
         })
+
+    def _get_default_collation(self, table_name):
+        with self.connection.cursor() as cursor:
+            cursor.execute("""
+                SELECT default_collation FROM user_tables WHERE table_name = %s
+            """, [self.normalize_name(table_name)])
+            return cursor.fetchone()[0]
+
+    def _alter_column_collation_sql(self, model, new_field, new_type, new_collation):
+        if new_collation is None:
+            new_collation = self._get_default_collation(model._meta.db_table)
+        return super()._alter_column_collation_sql(model, new_field, new_type, new_collation)
diff --git a/django/db/backends/postgresql/features.py b/django/db/backends/postgresql/features.py
--- a/django/db/backends/postgresql/features.py
+++ b/django/db/backends/postgresql/features.py
@@ -59,6 +59,7 @@ class DatabaseFeatures(BaseDatabaseFeatures):
     has_json_operators = True
     json_key_contains_list_matching_requires_list = True
     test_collations = {
+        'non_default': 'sv-x-icu',
         'swedish_ci': 'sv-x-icu',
     }

@@ -92,3 +93,4 @@ def is_postgresql_13(self):
     supports_table_partitions = property(operator.attrgetter('is_postgresql_10'))
     supports_covering_indexes = property(operator.attrgetter('is_postgresql_11'))
     supports_covering_gist_indexes = property(operator.attrgetter('is_postgresql_12'))
+    supports_non_deterministic_collations = property(operator.attrgetter('is_postgresql_12'))
diff --git a/django/db/backends/postgresql/introspection.py b/django/db/backends/postgresql/introspection.py
--- a/django/db/backends/postgresql/introspection.py
+++ b/django/db/backends/postgresql/introspection.py
@@ -69,9 +69,11 @@ def get_table_description(self, cursor, table_name):
             SELECT
                 a.attname AS column_name,
                 NOT (a.attnotnull OR (t.typtype = 'd' AND t.typnotnull)) AS is_nullable,
-                pg_get_expr(ad.adbin, ad.adrelid) AS column_default
+                pg_get_expr(ad.adbin, ad.adrelid) AS column_default,
+                CASE WHEN collname = 'default' THEN NULL ELSE collname END AS collation
             FROM pg_attribute a
             LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum
+            LEFT JOIN pg_collation co ON a.attcollation = co.oid
             JOIN pg_type t ON a.atttypid = t.oid
             JOIN pg_class c ON a.attrelid = c.oid
             JOIN pg_namespace n ON c.relnamespace = n.oid
diff --git a/django/db/backends/sqlite3/features.py b/django/db/backends/sqlite3/features.py
--- a/django/db/backends/sqlite3/features.py
+++ b/django/db/backends/sqlite3/features.py
@@ -47,6 +47,7 @@ class DatabaseFeatures(BaseDatabaseFeatures):
     test_collations = {
         'ci': 'nocase',
         'cs': 'binary',
+        'non_default': 'nocase',
     }

     @cached_property
diff --git a/django/db/backends/sqlite3/introspection.py b/django/db/backends/sqlite3/introspection.py
--- a/django/db/backends/sqlite3/introspection.py
+++ b/django/db/backends/sqlite3/introspection.py
@@ -84,6 +84,7 @@ def get_table_description(self, cursor, table_name):
         """
         cursor.execute('PRAGMA table_info(%s)' % self.connection.ops.quote_name(table_name))
         table_info = cursor.fetchall()
+        collations = self._get_column_collations(cursor, table_name)
         json_columns = set()
         if self.connection.features.can_introspect_json_field:
             for line in table_info:
@@ -102,7 +103,7 @@ def get_table_description(self, cursor, table_name):
         return [
             FieldInfo(
                 name, data_type, None, get_field_size(data_type), None, None,
-                not notnull, default, pk == 1, name in json_columns
+                not notnull, default, collations.get(name), pk == 1, name in json_columns
             )
             for cid, name, data_type, notnull, default, pk in table_info
         ]
@@ -435,3 +436,27 @@ def get_constraints(self, cursor, table_name):
             }
         constraints.update(self._get_foreign_key_constraints(cursor, table_name))
         return constraints
+
+    def _get_column_collations(self, cursor, table_name):
+        row = cursor.execute("""
+            SELECT sql
+            FROM sqlite_master
+            WHERE type = 'table' AND name = %s
+        """, [table_name]).fetchone()
+        if not row:
+            return {}
+
+        sql = row[0]
+        columns = str(sqlparse.parse(sql)[0][-1]).strip('()').split(', ')
+        collations = {}
+        for column in columns:
+            tokens = column[1:].split()
+            column_name = tokens[0].strip('"')
+            for index, token in enumerate(tokens):
+                if token == 'COLLATE':
+                    collation = tokens[index + 1]
+                    break
+            else:
+                collation = None
+            collations[column_name] = collation
+        return collations
diff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py
--- a/django/db/backends/sqlite3/schema.py
+++ b/django/db/backends/sqlite3/schema.py
@@ -429,3 +429,6 @@ def remove_constraint(self, model, constraint):
             super().remove_constraint(model, constraint)
         else:
             self._remake_table(model)
+
+    def _collate_sql(self, collation):
+        return ' COLLATE ' + collation
diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py
--- a/django/db/models/fields/__init__.py
+++ b/django/db/models/fields/__init__.py
@@ -1002,13 +1002,16 @@ def formfield(self, **kwargs):
 class CharField(Field):
     description = _("String (up to %(max_length)s)")

-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, db_collation=None, **kwargs):
         super().__init__(*args, **kwargs)
+        self.db_collation = db_collation
         self.validators.append(validators.MaxLengthValidator(self.max_length))

     def check(self, **kwargs):
+        databases = kwargs.get('databases') or []
         return [
             *super().check(**kwargs),
+            *self._check_db_collation(databases),
             *self._check_max_length_attribute(**kwargs),
         ]

@@ -1033,6 +1036,27 @@ def _check_max_length_attribute(self, **kwargs):
         else:
             return []

+    def _check_db_collation(self, databases):
+        errors = []
+        for db in databases:
+            if not router.allow_migrate_model(db, self.model):
+                continue
+            connection = connections[db]
+            if not (
+                self.db_collation is None or
+                'supports_collation_on_charfield' in self.model._meta.required_db_features or
+                connection.features.supports_collation_on_charfield
+            ):
+                errors.append(
+                    checks.Error(
+                        '%s does not support a database collation on '
+                        'CharFields.' % connection.display_name,
+                        obj=self,
+                        id='fields.E190',
+                    ),
+                )
+        return errors
+
     def cast_db_type(self, connection):
         if self.max_length is None:
             return connection.ops.cast_char_field_without_max_length
@@ -1061,6 +1085,12 @@ def formfield(self, **kwargs):
         defaults.update(kwargs)
         return super().formfield(**defaults)

+    def deconstruct(self):
+        name, path, args, kwargs = super().deconstruct()
+        if self.db_collation:
+            kwargs['db_collation'] = self.db_collation
+        return name, path, args, kwargs
+

 class CommaSeparatedIntegerField(CharField):
     default_validators = [validators.validate_comma_separated_integer_list]
@@ -2074,6 +2104,38 @@ def get_internal_type(self):
 class TextField(Field):
     description = _("Text")

+    def __init__(self, *args, db_collation=None, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.db_collation = db_collation
+
+    def check(self, **kwargs):
+        databases = kwargs.get('databases') or []
+        return [
+            *super().check(**kwargs),
+            *self._check_db_collation(databases),
+        ]
+
+    def _check_db_collation(self, databases):
+        errors = []
+        for db in databases:
+            if not router.allow_migrate_model(db, self.model):
+                continue
+            connection = connections[db]
+            if not (
+                self.db_collation is None or
+                'supports_collation_on_textfield' in self.model._meta.required_db_features or
+                connection.features.supports_collation_on_textfield
+            ):
+                errors.append(
+                    checks.Error(
+                        '%s does not support a database collation on '
+                        'TextFields.' % connection.display_name,
+                        obj=self,
+                        id='fields.E190',
+                    ),
+                )
+        return errors
+
     def get_internal_type(self):
         return "TextField"

@@ -2096,6 +2158,12 @@ def formfield(self, **kwargs):
             **kwargs,
         })

+    def deconstruct(self):
+        name, path, args, kwargs = super().deconstruct()
+        if self.db_collation:
+            kwargs['db_collation'] = self.db_collation
+        return name, path, args, kwargs
+

 class TimeField(DateTimeCheckMixin, Field):
     empty_strings_allowed = False

</patch>

--------------------------------------------------
analyze
Prompt implementation details are unclear
The description of Issue is not clear enough, too simple, and does not give specific requirements, making it difficult for the model to generate reasonable CoT steps based on the issue.
text:
<issue>
Make validators include the provided value in ValidationError
Description

It is sometimes desirable to include the provide value in a custom error message. For example:
“blah” is not a valid email.
By making built-in validators provide value to ValidationError, one can override an error message and use a %(value)s placeholder.
This placeholder value matches an example already in the docs:
​https://docs.djangoproject.com/en/3.0/ref/validators/#writing-validators

</issue>

steps:

1. Modify the `ValidationError` handling in Django's validators to include the provided value in the error message.
    1.1 Locate the `ValidationError` in the validator classes.
    1.2 Modify the error message to include a placeholder for the value being validated.
    1.3 Update the `params` argument to pass the value of the field being validated.
    1.4 Adjust the `ValidationError` raising mechanism to handle the new formatting.

2. Adjust the existing validators in Django to support a `%value` placeholder in their error messages.
    2.1 Modify the `MinimumLengthValidator` to include the provided password value in the error message.
    2.2 Modify the `UserAttributeSimilarityValidator` to include the username or email value in the error message.
    2.3 Modify the `CommonPasswordValidator` to include the password value in the error message.
    2.4 Modify the `NumericPasswordValidator` to include the provided password value in the error message.

3. Test the validators with custom error messages to verify that the provided value is included.
    3.1 Implement test cases that pass values through the validators.
    3.2 Verify that the error messages are formatted correctly and include the placeholder for the value.

model_patch:

--- a/django/contrib/auth/password_validation.py
+++ b/django/contrib/auth/password_validation.py
@@ -100,7 +100,8 @@
             raise ValidationError(
-                ngettext(
-                    "This password is too short. It must contain at least %(min_length)d character.",
-                    "This password is too short. It must contain at least %(min_length)d characters.",
-                    self.min_length
-                ),
+                _("The provided password '%(value)s' is too short. It must contain at least %(min_length)d characters.") % {'value': password},
                 code='password_too_short',
+                params={'min_length': self.min_length},
             )
@@ -151,7 +152,8 @@
                         _("The password is too similar to the %(verbose_name)s."),
+                         params={'verbose_name': verbose_name, 'value': password}
                     )
--- a/django/contrib/auth/management/commands/createsuperuser.py
+++ b/django/contrib/auth/management/commands/createsuperuser.py
@@ -240,7 +240,8 @@
             return '%s cannot be blank.' % capfirst(verbose_field_name)
         try:
             self.username_field.clean(username, None)
         except exceptions.ValidationError as e:
-            return '; '.join(e.messages)
+            return '; '.join([msg % {'value': username} if '%(value)s' in msg else msg for msg in e.messages])
--- a/django/contrib/auth/validators.py
+++ b/django/contrib/auth/validators.py
@@ -154,7 +154,8 @@
             raise ValidationError(
-                _("This password is too common."),
+                _("The password '%(value)s' is too common.") % {'value': password},
                 code='password_too_common',
             )
@@ -198,7 +199,8 @@
             raise ValidationError(
-                _("This password is entirely numeric."),
+                _("The password '%(value)s' is entirely numeric.") % {'value': password},
                 code='password_entirely_numeric',
             )


gold_patch:
<patch>
diff --git a/django/core/validators.py b/django/core/validators.py
--- a/django/core/validators.py
+++ b/django/core/validators.py
@@ -48,7 +48,7 @@ def __call__(self, value):
         regex_matches = self.regex.search(str(value))
         invalid_input = regex_matches if self.inverse_match else not regex_matches
         if invalid_input:
-            raise ValidationError(self.message, code=self.code)
+            raise ValidationError(self.message, code=self.code, params={'value': value})

     def __eq__(self, other):
         return (
@@ -100,11 +100,11 @@ def __init__(self, schemes=None, **kwargs):

     def __call__(self, value):
         if not isinstance(value, str):
-            raise ValidationError(self.message, code=self.code)
+            raise ValidationError(self.message, code=self.code, params={'value': value})
         # Check if the scheme is valid.
         scheme = value.split('://')[0].lower()
         if scheme not in self.schemes:
-            raise ValidationError(self.message, code=self.code)
+            raise ValidationError(self.message, code=self.code, params={'value': value})

         # Then check full URL
         try:
@@ -115,7 +115,7 @@ def __call__(self, value):
                 try:
                     scheme, netloc, path, query, fragment = urlsplit(value)
                 except ValueError:  # for example, "Invalid IPv6 URL"
-                    raise ValidationError(self.message, code=self.code)
+                    raise ValidationError(self.message, code=self.code, params={'value': value})
                 try:
                     netloc = punycode(netloc)  # IDN -> ACE
                 except UnicodeError:  # invalid domain part
@@ -132,14 +132,14 @@ def __call__(self, value):
                 try:
                     validate_ipv6_address(potential_ip)
                 except ValidationError:
-                    raise ValidationError(self.message, code=self.code)
+                    raise ValidationError(self.message, code=self.code, params={'value': value})

         # The maximum length of a full host name is 253 characters per RFC 1034
         # section 3.1. It's defined to be 255 bytes or less, but this includes
         # one byte for the length of the name and one byte for the trailing dot
         # that's used to indicate absolute names in DNS.
         if len(urlsplit(value).netloc) > 253:
-            raise ValidationError(self.message, code=self.code)
+            raise ValidationError(self.message, code=self.code, params={'value': value})


 integer_validator = RegexValidator(
@@ -208,12 +208,12 @@ def __init__(self, message=None, code=None, allowlist=None, *, whitelist=None):

     def __call__(self, value):
         if not value or '@' not in value:
-            raise ValidationError(self.message, code=self.code)
+            raise ValidationError(self.message, code=self.code, params={'value': value})

         user_part, domain_part = value.rsplit('@', 1)

         if not self.user_regex.match(user_part):
-            raise ValidationError(self.message, code=self.code)
+            raise ValidationError(self.message, code=self.code, params={'value': value})

         if (domain_part not in self.domain_allowlist and
                 not self.validate_domain_part(domain_part)):
@@ -225,7 +225,7 @@ def __call__(self, value):
             else:
                 if self.validate_domain_part(domain_part):
                     return
-            raise ValidationError(self.message, code=self.code)
+            raise ValidationError(self.message, code=self.code, params={'value': value})

     def validate_domain_part(self, domain_part):
         if self.domain_regex.match(domain_part):
@@ -272,12 +272,12 @@ def validate_ipv4_address(value):
     try:
         ipaddress.IPv4Address(value)
     except ValueError:
-        raise ValidationError(_('Enter a valid IPv4 address.'), code='invalid')
+        raise ValidationError(_('Enter a valid IPv4 address.'), code='invalid', params={'value': value})


 def validate_ipv6_address(value):
     if not is_valid_ipv6_address(value):
-        raise ValidationError(_('Enter a valid IPv6 address.'), code='invalid')
+        raise ValidationError(_('Enter a valid IPv6 address.'), code='invalid', params={'value': value})


 def validate_ipv46_address(value):
@@ -287,7 +287,7 @@ def validate_ipv46_address(value):
         try:
             validate_ipv6_address(value)
         except ValidationError:
-            raise ValidationError(_('Enter a valid IPv4 or IPv6 address.'), code='invalid')
+            raise ValidationError(_('Enter a valid IPv4 or IPv6 address.'), code='invalid', params={'value': value})


 ip_address_validator_map = {
@@ -438,7 +438,7 @@ def __init__(self, max_digits, decimal_places):
     def __call__(self, value):
         digit_tuple, exponent = value.as_tuple()[1:]
         if exponent in {'F', 'n', 'N'}:
-            raise ValidationError(self.messages['invalid'])
+            raise ValidationError(self.messages['invalid'], code='invalid', params={'value': value})
         if exponent >= 0:
             # A positive exponent adds that many trailing zeros.
             digits = len(digit_tuple) + exponent
@@ -460,20 +460,20 @@ def __call__(self, value):
             raise ValidationError(
                 self.messages['max_digits'],
                 code='max_digits',
-                params={'max': self.max_digits},
+                params={'max': self.max_digits, 'value': value},
             )
         if self.decimal_places is not None and decimals > self.decimal_places:
             raise ValidationError(
                 self.messages['max_decimal_places'],
                 code='max_decimal_places',
-                params={'max': self.decimal_places},
+                params={'max': self.decimal_places, 'value': value},
             )
         if (self.max_digits is not None and self.decimal_places is not None and
                 whole_digits > (self.max_digits - self.decimal_places)):
             raise ValidationError(
                 self.messages['max_whole_digits'],
                 code='max_whole_digits',
-                params={'max': (self.max_digits - self.decimal_places)},
+                params={'max': (self.max_digits - self.decimal_places), 'value': value},
             )

     def __eq__(self, other):
@@ -509,7 +509,8 @@ def __call__(self, value):
                 code=self.code,
                 params={
                     'extension': extension,
-                    'allowed_extensions': ', '.join(self.allowed_extensions)
+                    'allowed_extensions': ', '.join(self.allowed_extensions),
+                    'value': value,
                 }
             )

@@ -550,7 +551,7 @@ def __init__(self, message=None, code=None):

     def __call__(self, value):
         if '\x00' in str(value):
-            raise ValidationError(self.message, code=self.code)
+            raise ValidationError(self.message, code=self.code, params={'value': value})

     def __eq__(self, other):
         return (
diff --git a/django/forms/fields.py b/django/forms/fields.py
--- a/django/forms/fields.py
+++ b/django/forms/fields.py
@@ -350,13 +350,6 @@ def to_python(self, value):
             raise ValidationError(self.error_messages['invalid'], code='invalid')
         return value

-    def validate(self, value):
-        super().validate(value)
-        if value in self.empty_values:
-            return
-        if not value.is_finite():
-            raise ValidationError(self.error_messages['invalid'], code='invalid')
-
     def widget_attrs(self, widget):
         attrs = super().widget_attrs(widget)
         if isinstance(widget, NumberInput) and 'step' not in widget.attrs:

</patch>

--------------------------------------------------
analyze
CoT and propt are inconsistent
What Prompt needs is to improve the error message mechanism of the Django validator so that it contains the value that failed when throwing a ValidationError so that the developer can use the value in a custom error message. Instead of outputting the wrong password when the user enters the password to issue an error in step 2. CoT is inconsistent with the propt requirement.
text:
<issue>
Allow ValidationErrors to equal each other when created identically
Description

		(last modified by kamni)

Currently ValidationErrors (django.core.exceptions.ValidationError) that have identical messages don't equal each other, which is counter-intuitive, and can make certain kinds of testing more complicated. Please add an __eq__ method that allows two ValidationErrors to be compared.
Ideally, this would be more than just a simple self.messages == other.messages. It would be most helpful if the comparison were independent of the order in which errors were raised in a field or in non_field_errors.

</issue>

steps:

1. Identify the classes where the `ValidationError` class is defined and determine the structure of the `__eq__` method.
    1.1 Locate `ValidationError` in the `django/core/exceptions.py` file.
    1.2 Check the current implementation of `ValidationError` for its properties, specifically how the `message` and `error_list` are handled.
    1.3 Identify that the `messages` property is a list but may need to be compared in an unordered manner, not considering the order of errors.
2. Add an `__eq__` method to `ValidationError` class.
    2.1 Implement comparison logic that handles both `error_list` and `error_dict` attributes (if present).
    2.2 Ensure that the `message` lists are compared in an order-independent manner using sorting.
    2.3 Ensure that both `error_list` and `error_dict` are considered for equality comparison.
3. Implement tests for the equality functionality of `ValidationError`.
    3.1 Write tests to check equality when the `ValidationError` objects have the same messages, regardless of order.
    3.2 Ensure that errors are considered equal even if the order of the errors is different.
    3.3 Check that `ValidationError` with different error messages or codes does not compare equal.
4. Update relevant parts of the code base to handle `ValidationError` comparisons correctly.
    4.1 Ensure that parts of the code using `ValidationError` respect the newly added `__eq__` method.
    4.2 Review the changes to ensure no existing functionality is broken by the equality comparison logic.

model_patch:

--- django/core/exceptions.py
+++ django/core/exceptions.py
@@ -99,6 +99,25 @@

     def __str__(self):
         if hasattr(self, 'error_dict'):
             return repr(dict(self))
         return repr(list(self))

+    def __eq__(self, other):
+        if not isinstance(other, ValidationError):
+            return False
+        if hasattr(self, 'error_dict') and hasattr(other, 'error_dict'):
+            if self.error_dict != other.error_dict:
+                return False
+        if hasattr(self, 'error_list') and hasattr(other, 'error_list'):
+            if sorted(self.error_list, key=lambda x: x.message) != sorted(other.error_list, key=lambda x: x.message):
+                return False
+        return self.message == other.message and self.code == other.code and self.params == other.params
+
--- django/forms/forms.py
+++ django/forms/forms.py
@@ -337,6 +337,7 @@
                 self._errors[field].extend(error_list)
@@ -341,6 +342
                 if hasattr(error, 'error_dict'):
                     self._errors[field] = error.error_dict
                     self._errors[field].extend(error_list)
                 elif hasattr(error, 'error_list'):
                     self._errors[field] = error.error_list
                     self._errors[field].extend(error_list)
                 else:
                     self._errors[field].extend(error_list)


gold_patch:
<patch>
diff --git a/django/core/exceptions.py b/django/core/exceptions.py
--- a/django/core/exceptions.py
+++ b/django/core/exceptions.py
@@ -1,6 +1,9 @@
 """
 Global Django exception and warning classes.
 """
+import operator
+
+from django.utils.hashable import make_hashable


 class FieldDoesNotExist(Exception):
@@ -182,6 +185,23 @@ def __str__(self):
     def __repr__(self):
         return 'ValidationError(%s)' % self

+    def __eq__(self, other):
+        if not isinstance(other, ValidationError):
+            return NotImplemented
+        return hash(self) == hash(other)
+
+    def __hash__(self):
+        # Ignore params and messages ordering.
+        if hasattr(self, 'message'):
+            return hash((
+                self.message,
+                self.code,
+                tuple(sorted(make_hashable(self.params))) if self.params else None,
+            ))
+        if hasattr(self, 'error_dict'):
+            return hash(tuple(sorted(make_hashable(self.error_dict))))
+        return hash(tuple(sorted(self.error_list, key=operator.attrgetter('message'))))
+

 class EmptyResultSet(Exception):
     """A database query predicate is impossible."""

</patch>

--------------------------------------------------
analyze
CoT and code are inconsistent
The CoT step is correct, but there is an error in the implementation of model_patch, which is wrongly changed the irrelevant file form.py, and there is a problem with the implementation logic of __eq__, which is wrong for the comparison of message.
